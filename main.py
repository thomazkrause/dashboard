import streamlit as st
import pandas as pd
from database import DatabaseManager
from data_processor import DataProcessor
from metrics_calculator import MetricsCalculator
from visualizations import Visualizations
from ui_components import UIComponents
from utils import formatar_moeda, get_ordem_faixas
from datetime import datetime, timedelta

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Dashboard Faturamento", 
    page_icon="üí∞", 
    layout="wide",
    initial_sidebar_state="expanded"
)

# Inicializar banco de dados
@st.cache_resource
def init_database():
    return DatabaseManager()

# CSS personalizado
st.markdown("""
<style>
    .main-header {
        text-align: center;
        padding: 1rem 0;
        margin-bottom: 2rem;
    }
    .database-status {
        padding: 0.5rem;
        border-radius: 0.5rem;
        margin-bottom: 1rem;
    }
</style>
""", unsafe_allow_html=True)

# T√≠tulo principal
st.markdown('<div class="main-header">', unsafe_allow_html=True)
st.title("üìä Dashboard de An√°lise de Faturamento")
st.markdown("*Dados persistentes com Supabase*")
st.markdown('</div>', unsafe_allow_html=True)
st.markdown("---")

# Inicializar componentes
db = init_database()
ui = UIComponents()

# Sidebar - Gerenciamento de Dados
st.sidebar.header("üíæ Gerenciamento de Dados")

# Status da conex√£o
if db.test_connection():
    if db.mode == "supabase":
        st.sidebar.success("‚úÖ Conectado ao Supabase")
    else:
        st.sidebar.warning("‚ö†Ô∏è Modo Mem√≥ria (dados tempor√°rios)")
    
    # Estat√≠sticas do banco
    stats = db.get_stats()
    if stats:
        st.sidebar.metric("üìä Total de Registros", stats.get('total_records', 0))
        st.sidebar.info(f"üîß Modo: {stats.get('mode', 'Unknown')}")
        if stats.get('last_update'):
            try:
                last_update = datetime.fromisoformat(stats['last_update'].replace('Z', '+00:00'))
                st.sidebar.info(f"üïí √öltima atualiza√ß√£o: {last_update.strftime('%d/%m/%Y %H:%M')}")
            except:
                st.sidebar.info(f"üïí √öltima atualiza√ß√£o: {stats['last_update']}")
else:
    st.sidebar.error("‚ùå Erro de conex√£o")

st.sidebar.markdown("---")

# Upload de novos dados
st.sidebar.subheader("üìÅ Upload de Dados")
uploaded_file = st.sidebar.file_uploader("Carregar CSV", type=['csv'])

if uploaded_file:
    try:
        new_df = pd.read_csv(uploaded_file)
        st.sidebar.success(f"‚úÖ {len(new_df)} registros no arquivo")
        
        # Preview dos dados
        with st.sidebar.expander("üëÄ Preview dos dados"):
            st.dataframe(new_df.head(3))
        
        col1, col2 = st.sidebar.columns(2)
        
        with col1:
            if st.button("üíæ Salvar no Banco", type="primary"):
                with st.spinner("Salvando dados..."):
                    result = db.insert_faturamento(new_df)
                    if result:
                        st.success(f"‚úÖ {result} registros salvos!")
                        st.rerun()
                    else:
                        st.error("‚ùå Erro ao salvar!")
        
        with col2:
            if st.button("üîÑ Substituir Dados"):
                if st.checkbox("‚ö†Ô∏è Confirmar substitui√ß√£o"):
                    with st.spinner("Substituindo dados..."):
                        db.delete_all_data()
                        result = db.insert_faturamento(new_df)
                        if result:
                            st.success(f"‚úÖ Dados substitu√≠dos! {result} registros")
                            st.rerun()
                        else:
                            st.error("‚ùå Erro na substitui√ß√£o!")
    
    except Exception as e:
        st.sidebar.error(f"‚ùå Erro ao ler arquivo: {str(e)}")

st.sidebar.markdown("---")

# Gerenciamento avan√ßado
with st.sidebar.expander("‚öôÔ∏è Gerenciamento Avan√ßado"):
    if st.button("üóëÔ∏è Limpar Todos os Dados", type="secondary"):
        if st.checkbox("‚ö†Ô∏è CONFIRMO que quero apagar TODOS os dados"):
            if db.delete_all_data():
                st.success("üóëÔ∏è Todos os dados foram removidos!")
                st.rerun()
            else:
                st.error("‚ùå Erro ao limpar dados!")

# Carregar dados do banco
try:
    with st.spinner("Carregando dados do banco..."):
        df = db.get_all_faturamento()
    
    if not df.empty:
        st.success(f"‚úÖ {len(df)} registros carregados do banco de dados!")
        
        # Debug: mostrar colunas dispon√≠veis
        with st.expander("üîç Debug - Colunas dispon√≠veis"):
            st.write("Colunas no DataFrame:", list(df.columns))
            st.write("Primeiras linhas:")
            st.dataframe(df.head())
        
        # Processar dados
        processor = DataProcessor(df)
        df = processor.df
        
        # Inicializar componentes de an√°lise
        calculator = MetricsCalculator(df)
        viz = Visualizations()
        
        # Calcular LTV por cliente
        ltv_por_cliente = processor.get_ltv_por_cliente()
        
        # **DASHBOARD PRINCIPAL - TODOS OS GR√ÅFICOS E INDICADORES**
        
        # Exibir KPIs principais
        kpis = calculator.calculate_basic_kpis()
        ui.display_basic_kpis(kpis)
        
        # Exibir valores por situa√ß√£o
        valores_situacao = calculator.calculate_valores_por_situacao()
        ui.display_valores_situacao(valores_situacao)
        
        # Exibir m√©tricas avan√ßadas
        advanced_metrics = calculator.calculate_advanced_metrics()
        ui.display_advanced_metrics(advanced_metrics)
        
        # An√°lise por Faixa de Cliente
        st.header("üèÜ An√°lise por Faixa de Cliente (LTV)")
        
        if not ltv_por_cliente.empty:
            # Calcular estat√≠sticas por faixa
            faixa_stats = calculator.calculate_faixa_stats(ltv_por_cliente)
            
            if not faixa_stats.empty:
                # Ordenar por import√¢ncia
                ordem_faixas = get_ordem_faixas()
                faixa_stats = faixa_stats.reindex(ordem_faixas)
                
                # Exibir resumo por faixa
                ui.display_faixa_summary(faixa_stats)
                
                # Gr√°ficos de faixa
                col1, col2 = st.columns(2)
                
                with col1:
                    fig_pizza = viz.create_faixa_pizza_chart(faixa_stats)
                    st.plotly_chart(fig_pizza, use_container_width=True)
                
                with col2:
                    fig_bar = viz.create_faixa_bar_chart(faixa_stats)
                    st.plotly_chart(fig_bar, use_container_width=True)
                
                # Evolu√ß√£o mensal por faixa
                st.subheader("üìà Evolu√ß√£o Mensal por Faixa de Cliente")
                
                if 'Mes_Ano' in df.columns:
                    df_com_faixa = processor.get_df_com_faixa(ltv_por_cliente)
                    
                    if not df_com_faixa.empty:
                        evolucao_mensal = df_com_faixa.groupby(['Mes_Ano', 'Faixa_Cliente'])['Total'].sum().reset_index()
                        evolucao_mensal['Mes_Ano_Str'] = evolucao_mensal['Mes_Ano'].astype(str)
                        
                        fig_evolucao = viz.create_evolucao_mensal_chart(evolucao_mensal)
                        st.plotly_chart(fig_evolucao, use_container_width=True)
                        
                        # Tabela de evolu√ß√£o
                        pivot_evolucao = evolucao_mensal.pivot(
                            index='Mes_Ano_Str', 
                            columns='Faixa_Cliente', 
                            values='Total'
                        ).fillna(0)
                        st.write("üìã **Tabela de Evolu√ß√£o Mensal:**")
                        st.dataframe(pivot_evolucao.round(2), use_container_width=True)
                else:
                    st.warning("‚ö†Ô∏è Coluna 'Mes_Ano' n√£o encontrada. Verifique o processamento de datas.")
        else:
            st.warning("‚ö†Ô∏è N√£o foi poss√≠vel calcular LTV por cliente. Verifique se existem dados com situa√ß√£o 'Paga'.")
        
        # Ranking de Clientes
        st.header("üèÜ Ranking de Clientes por Valor")
        
        ranking_clientes = calculator.calculate_ranking_clientes()
        
        if not ranking_clientes.empty:
            total_geral = ranking_clientes['Valor_Total'].sum()
            
            col1, col2 = st.columns([2, 1])
            
            with col1:
                st.subheader("ü•á Top 20 Clientes")
                
                # Formata√ß√£o para exibi√ß√£o
                ranking_display = ranking_clientes.head(20).copy()
                ranking_display['Valor_Total'] = ranking_display['Valor_Total'].apply(formatar_moeda)
                ranking_display['Percentual'] = ranking_display['Percentual'].apply(lambda x: f"{x:.2f}%")
                ranking_display['Percentual_Acumulado'] = ranking_display['Percentual_Acumulado'].apply(lambda x: f"{x:.2f}%")
                
                # Renomear colunas para exibi√ß√£o
                ranking_display = ranking_display[['Nome', 'Valor_Total', 'Percentual', 'Percentual_Acumulado', 'Num_Transacoes', 'Faixa']]
                ranking_display.columns = ['Cliente', 'Valor Total', '% Individual', '% Acumulado', 'Transa√ß√µes', 'Faixa']
                
                st.dataframe(ranking_display, use_container_width=True, hide_index=True)
            
            with col2:
                ui.display_ranking_analysis(ranking_clientes, total_geral)
            
            # Gr√°fico de Pareto
            st.subheader("üìà An√°lise de Pareto - Concentra√ß√£o de Clientes")
            
            pareto_data = ranking_clientes.head(30)
            fig_pareto = viz.create_pareto_chart(pareto_data)
            st.plotly_chart(fig_pareto, use_container_width=True)
        else:
            st.warning("‚ö†Ô∏è N√£o foi poss√≠vel calcular ranking de clientes.")
        
        # Evolu√ß√£o Mensal por Status
        st.header("üìä Evolu√ß√£o Mensal por Status")
        
        if 'Mes_Ano' in df.columns and 'Total' in df.columns and 'Situa√ß√£o' in df.columns:
            df_mensal_status = df.groupby(['Mes_Ano', 'Situa√ß√£o'])['Total'].sum().reset_index()
            df_mensal_status['Mes_Ano_Str'] = df_mensal_status['Mes_Ano'].astype(str)
            
            fig_mensal = viz.create_evolucao_status_chart(df_mensal_status)
            st.plotly_chart(fig_mensal, use_container_width=True)
        else:
            st.warning("‚ö†Ô∏è Dados insuficientes para evolu√ß√£o mensal por status.")
        
        # An√°lises Visuais
        st.header("üìä An√°lises Visuais")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if 'Situa√ß√£o' in df.columns:
                situacao_counts = df['Situa√ß√£o'].value_counts()
                fig_situacao = viz.create_situacao_pie_chart(situacao_counts)
                st.plotly_chart(fig_situacao, use_container_width=True)
            else:
                st.warning("‚ö†Ô∏è Coluna 'Situa√ß√£o' n√£o encontrada.")
        
        with col2:
            if 'Paga com' in df.columns:
                metodos_pagamento = df['Paga com'].value_counts()
                fig_pagamento = viz.create_pagamento_pie_chart(metodos_pagamento)
                st.plotly_chart(fig_pagamento, use_container_width=True)
            else:
                st.warning("‚ö†Ô∏è Coluna 'Paga com' n√£o encontrada.")
        
        # Dados Detalhados
        st.header("üìã Dados Detalhados")
        
        col1, col2 = st.columns(2)
        
        with col1:
            situacoes_disponiveis = ['Todas']
            if 'Situa√ß√£o' in df.columns:
                situacoes_disponiveis += list(df['Situa√ß√£o'].unique())
            situacao_selecionada = st.selectbox("üîç Filtrar por situa√ß√£o:", situacoes_disponiveis)
        
        with col2:
            metodos_disponiveis = ['Todos']
            if 'Paga com' in df.columns:
                metodos_disponiveis += list(df['Paga com'].unique())
            metodo_selecionado = st.selectbox("üîç Filtrar por m√©todo de pagamento:", metodos_disponiveis)
        
        # Aplicar filtros
        df_filtrado = processor.apply_filters(situacao_selecionada, metodo_selecionado)
        
        if len(df_filtrado) != len(df):
            st.info(f"üìä Exibindo {len(df_filtrado)} de {len(df)} registros (filtrados)")
        
        st.dataframe(df_filtrado.head(50), use_container_width=True)
        
        if len(df_filtrado) > 50:
            st.info(f"Mostrando 50 de {len(df_filtrado)} registros filtrados")
        
    else:
        # Instru√ß√µes quando n√£o h√° dados
        st.info("üìù **Nenhum dado encontrado no banco.**")
        
        col1, col2, col3 = st.columns([1,2,1])
        with col2:
            st.markdown("""
            ### üöÄ Como come√ßar:
            
            1. **üìÅ Upload**: Use a barra lateral para fazer upload do seu CSV
            2. **üíæ Salvar**: Clique em "Salvar no Banco" para persistir os dados
            3. **üìä Analisar**: O dashboard ser√° carregado automaticamente
            
            ### üìã Formato esperado do CSV:
            - `Nome`: Nome do cliente
            - `CPF/CNPJ`: Documento do cliente  
            - `Total`: Valor da transa√ß√£o
            - `Taxa`: Taxa cobrada
            - `Situa√ß√£o`: Status (Paga, Pendente, Expirado)
            - `Paga com`: M√©todo de pagamento
            - `Data de cria√ß√£o`: Data da transa√ß√£o
            - `Data do pagamento`: Data do pagamento (se aplic√°vel)
            """)
        
        ui.display_instructions()
        
except Exception as e:
    st.error(f"‚ùå Erro ao carregar dados: {str(e)}")
    st.info("üí° Verifique a conex√£o com o Supabase e tente novamente.")
    
    # Debug adicional
    with st.expander("üîç Debug do erro"):
        import traceback
        st.code(traceback.format_exc())